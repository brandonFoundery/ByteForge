-- Generated by Claude Requirements Engine
-- Document Type: DB-SCHEMA
-- Generated: 2025-06-02T15:58:39.485322
-- Version: 1.0

I'll create a production-ready PostgreSQL schema based on the requirements. I'll include table definitions, constraints, indexes, and some sample data.

```sql
-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Create custom types
CREATE TYPE user_status AS ENUM ('active', 'inactive', 'locked');
CREATE TYPE permission_action AS ENUM ('create', 'read', 'update', 'delete');

-- Users table
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    password_hash VARCHAR(256) NOT NULL,
    status user_status NOT NULL DEFAULT 'active',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,

    CONSTRAINT users_username_check CHECK (username ~* '^[a-zA-Z0-9_]{3,50}$'),
    CONSTRAINT users_email_check CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    CONSTRAINT users_username_unique UNIQUE (username),
    CONSTRAINT users_email_unique UNIQUE (email)
);

-- Roles table
CREATE TABLE roles (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(50) NOT NULL,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT roles_name_unique UNIQUE (name)
);

-- Permissions table
CREATE TABLE permissions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(50) NOT NULL,
    resource VARCHAR(100) NOT NULL,
    action permission_action NOT NULL,
    
    CONSTRAINT permissions_name_unique UNIQUE (name),
    CONSTRAINT permissions_resource_action_unique UNIQUE (resource, action)
);

-- User-Role junction table
CREATE TABLE user_roles (
    user_id UUID NOT NULL,
    role_id UUID NOT NULL,
    assigned_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    PRIMARY KEY (user_id, role_id),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE
);

-- Role-Permission junction table
CREATE TABLE role_permissions (
    role_id UUID NOT NULL,
    permission_id UUID NOT NULL,
    assigned_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    PRIMARY KEY (role_id, permission_id),
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE,
    FOREIGN KEY (permission_id) REFERENCES permissions(id) ON DELETE CASCADE
);

-- Indexes
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_status ON users(status);
CREATE INDEX idx_user_roles_user_id ON user_roles(user_id);
CREATE INDEX idx_user_roles_role_id ON user_roles(role_id);
CREATE INDEX idx_role_permissions_role_id ON role_permissions(role_id);
CREATE INDEX idx_role_permissions_permission_id ON role_permissions(permission_id);

-- Trigger for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Sample seed data
INSERT INTO roles (id, name, description) VALUES
    (uuid_generate_v4(), 'admin', 'System Administrator'),
    (uuid_generate_v4(), 'user', 'Regular User');

INSERT INTO permissions (id, name, resource, action) VALUES
    (uuid_generate_v4(), 'create_user', 'users', 'create'),
    (uuid_generate_v4(), 'read_user', 'users', 'read'),
    (uuid_generate_v4(), 'update_user', 'users', 'update'),
    (uuid_generate_v4(), 'delete_user', 'users', 'delete');

-- Insert sample admin user (password_hash would be properly hashed in application)
INSERT INTO users (id, username, email, password_hash, status) VALUES
    (uuid_generate_v4(), 'admin', 'admin@example.com', 'hashed_password_here', 'active');

-- Create views for common queries
CREATE VIEW active_users AS
    SELECT id, username, email, created_at
    FROM users
    WHERE status = 'active' AND deleted_at IS NULL;

CREATE VIEW user_permissions AS
    SELECT u.id as user_id, u.username, r.name as role_name, p.name as permission_name
    FROM users u
    JOIN user_roles ur ON u.id = ur.user_id
    JOIN roles r ON ur.role_id = r.id
    JOIN role_permissions rp ON r.id = rp.role_id
    JOIN permissions p ON rp.permission_id = p.id;

-- Comments
COMMENT ON TABLE users IS 'User accounts with authentication and status information';
COMMENT ON TABLE roles IS 'User roles for access control';
COMMENT ON TABLE permissions IS 'Granular permissions for resources and actions';
COMMENT ON TABLE user_roles IS 'Many-to-many relationship between users and roles';
COMMENT ON TABLE role_permissions IS 'Many-to-many relationship between roles and permissions';
```

This schema includes:

1. Tables for all required entities with appropriate data types
2. Primary and foreign key constraints
3. Check constraints for data validation
4. Indexes for performance optimization
5. Triggers for automatic timestamp updates
6. Sample seed data
7. Useful views for common queries
8. Table comments for documentation
9. Support for soft deletes
10. Proper email and username validation
11. Unique constraints where needed
12. Enum types for status and actions

The schema is optimized for:
- Security (password hashing, role-based access)
- Performance (appropriate indexes)
- Data integrity (constraints and validation)
- Maintainability (triggers, views, comments)
- Scalability (UUID as primary keys)

Let me know if you need any clarification or have specific requirements to adjust!